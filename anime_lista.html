<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Class Animes</title>

  <!-- TailwindCSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>

  <style>
    body {
      background: #0b0b0b;
      font-family: Inter, system-ui, sans-serif;
      color: #e6e6e6;
      padding-bottom: 100px; /* espa√ßo para menu inferior */
    }

    .menu {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: #151515;
      border-top: 1px solid #2a2a2a;
      display: flex;
      justify-content: space-around;
      padding: 10px 0;
    }

    .menu-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #b3b3b3;
      font-size: 0.75rem;
      transition: all 0.2s;
    }

    .menu-btn:hover,
    .menu-btn.active {
      color: #B9314F;
    }

    .menu-btn svg {
      width: 22px;
      height: 22px;
      margin-bottom: 4px;
    }

    /* --- Estilos do Menu Inferior (Navega√ß√£o) --- */
        .header-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: #151515;
            border-bottom: 1px solid #2a2a2a;
            padding: 10px 20px;
            z-index: 10;
        }


        .menu-btn i {
            margin-bottom: 4px;
        }
        
        /* --- Estilos do Dropdown de Mais Op√ß√µes --- */
        .dropdown-item {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 8px;
            width: 100%;
            padding: 8px 10px;
            color: #e6e6e6;
            font-size: 0.875rem; /* text-sm */
            border-radius: 6px; /* rounded-lg */
            transition: background-color 0.2s;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
        }

        .dropdown-item:hover {
            background-color: #2a2a2a;
        }

        /* --- Estilos do Dropdown de Filtro Customizado (VISUAL MELHORADO) --- */
        .filter-dropdownMenu {
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 20;
            width: 100%;
            background: #1f1f1f;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
            margin-top: 4px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
        }

        .filter-option {
            /* Estilos para parecer um item de lista clic√°vel */
            padding: 10px 15px;
            cursor: pointer;
            transition: background-color 0.15s;
            
            /* Adicionando estilos para √≠cones e alinhamento */
            display: flex;
            align-items: center;
            gap: 10px; /* Espa√ßamento entre √≠cone e texto */
            
            /* Para usar como <button> e parecer um item de lista */
            width: 100%; 
            text-align: left; 
            background: none;
            border: none;
            color: inherit; /* Garante que o texto herde a cor do body/pai */
            font-size: 1rem; /* Tamanho da fonte padr√£o */
        }

        .filter-option:hover {
            background-color: #2a2a2a;
        }

        .filter-option.selected {
            background-color: #B9314F;
            color: #ffffff;
        }

        /* --- Estilos do Card de Anime --- */
        .anime-card {
            background: #151515;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .anime-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(185, 49, 79, 0.2);
        }

        .card-image {
            width: 100%;
            padding-top: 150%; /* 3:2 Aspect Ratio */
            position: relative;
        }

        .card-image img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .modal-top {
            z-index: 99999 !important;
        }
  </style>
</head>
<body>

<div id="app" class="container mx-auto max-w-6xl px-4 pt-4">

  <!-- MENU SUPERIOR -->
  <header class="bg-[#1f1f1f] p-2 mb-3 shadow-xl rounded-xl border border-[#2a2a2a]">
    
    <!-- Linha 1 -->
    <div class="flex justify-between items-center">
      <button onclick="window.location.href='home.html'"
              class="text-2xl font-bold text-[#B9314F] hover:text-[#992743] transition-colors duration-200">
        My Hub
      </button>

      <h1 class="text-2xl font-bold text-white">My Animes</h1>
    </div>

    <!-- Linha 2 -->
    <div class="text-sm text-gray-300 mt-1">
      Usu√°rio: <span id="user-email" class="text-[#B9314F] font-mono">Carregando...</span>
    </div>

  </header>

  <!-- CONTE√öDO PRINCIPAL DA P√ÅGINA -->
    <main class="container mx-auto p-4 pt-6">

        <!-- Removido: <h2 class="text-3xl font-extrabold mb-6 text-white">Minha Lista de Animes</h2> -->

        <!-- NOVO DROPDOWN DE VISUALIZA√á√ÉO (Filtros) - Ajustado para w-full (responsivo) -->
        <div class="relative w-full mb-6">
            <button id="dropdown-toggle"
                    class="w-full flex justify-between items-center px-4 py-2 bg-[#1f1f1f] text-white
                           border border-[#333] rounded-lg shadow-md hover:bg-[#2a2a2a] transition-colors"
                    onclick="toggleFilterDropdown()">
                <span id="selected-filter-text">Todos</span>
                <i data-lucide="chevron-down" class="w-5 h-5 transition-transform duration-200"></i>
            </button>

            <div id="dropdownMenu" class="filter-dropdownMenu hidden">
                <div class="filter-option selected" data-filter="inacabados" data-text="Todos inacabados" onclick="loadAnimeList('inacabados')">
                    Todos inacabados
                </div>
                <div class="filter-option" data-filter="temporada" data-text="Termporada Atual" onclick="loadAnimeList('temporada')">
                    Termporada Atual
                </div>
                <div class="filter-option" data-filter="ult_temporada" data-text="√öltima Temporada" onclick="loadAnimeList('ult_temporada')">
                    √öltima Temporada
                </div>
                <div class="filter-option" data-filter="andamento" data-text="andamento" onclick="loadAnimeList('andamento')">
                    Andamento
                </div>
            </div>
        </div>
        
        <!-- CARREGAMENTO/ERRO -->
        <div id="loading-indicator" class="text-center p-10 hidden">
            <i data-lucide="loader-2" class="w-8 h-8 mx-auto animate-spin text-[#B9314F]"></i>
            <p class="mt-2 text-sm text-gray-400">Carregando animes...</p>
        </div>
        <div id="error-message" class="text-center p-10 hidden bg-red-900/20 border border-red-700/50 rounded-lg">
            <p class="text-red-400 text-sm">Ocorreu um erro ao carregar os dados. Verifique sua conex√£o.</p>
        </div>
        
        <!-- GRID DE CARDS -->
        <div id="anime-list-grid" class="grid grid-cols-2 gap-4 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5">
            <!-- Cards de animes ser√£o injetados aqui -->
        </div>
    </main>
</div>


<!-- MODAL DE ANIME (NOVO & FUNCIONAL) -->
<div id="anime-modal"
     class="fixed inset-0 hidden overflow-y-auto bg-black bg-opacity-75"
     style="z-index: 9999;">

    <div class="relative w-11/12 max-w-lg mx-auto my-10 p-6 bg-[#2a2a2a] rounded-lg shadow-lg border border-gray-600">

        <!-- HEADER -->
        <div class="flex justify-between items-center pb-4 border-b border-gray-600">
            <button id="anime-close-btn"
                    class="p-2 rounded-full hover:bg-gray-700 transition"
                    type="button">
                <svg xmlns="http://www.w3.org/2000/svg"
                     class="h-6 w-6 text-gray-400"
                     viewBox="0 0 24 24"
                     fill="none"
                     stroke="currentColor">
                    <path stroke-linecap="round"
                          stroke-linejoin="round"
                          stroke-width="2"
                          d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>

        <!-- CONTE√öDO -->
        <div class="mt-4 space-y-4">

            <!-- CABE√áALHO COM IMAGEM E NOME -->
            <div class="flex items-start space-x-4 mb-4">
                <!-- Imagem quadrada -->
                <img id="modal-imagem"
                     class="w-16 h-16 rounded-lg border border-gray-600 shadow-lg flex-shrink-0"
                     alt="Anime">
                
                <!-- Nome do anime -->
                <div class="flex-1 min-w-0">
                    <h2 id="modal-nome" class="text-xl font-bold text-white break-words leading-tight">Anime</h2>
                </div>
            </div>

            <!-- INFORMA√á√ïES DETALHADAS -->
            <div id="modal-info" class="bg-[#1f1f1f] p-4 rounded-lg border border-gray-600">
                <div class="grid grid-cols-2 gap-3 text-sm">
                    <div class="flex justify-between">
                        <span class="text-gray-400">Epis√≥dios Assistidos:</span>
                        <span id="modal-eps-assistidos" class="text-white font-medium">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Epis√≥dios Totais:</span>
                        <span id="modal-eps-totais" class="text-white font-medium">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Estilo:</span>
                        <span id="modal-estilo" class="text-white font-medium">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Estado:</span>
                        <span id="modal-estado" class="text-white font-medium">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Ano:</span>
                        <span id="modal-ano" class="text-white font-medium">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Temporada:</span>
                        <span id="modal-temporada" class="text-white font-medium">-</span>
                    </div>
                </div>
            </div>

            <!-- BOT√ïES DE A√á√ÉO -->
            <div class="flex space-x-3">
                <button id="btn-openings" 
                        class="flex-1 bg-[#B9314F] hover:bg-[#992743] text-white font-medium py-3 px-4 rounded-lg transition-colors">
                    Openings
                </button>
                <button id="btn-estado" 
                        class="flex-1 bg-[#4F46E5] hover:bg-[#4338CA] text-white font-medium py-3 px-4 rounded-lg transition-colors">
                    Estado
                </button>
                <button id="btn-episodio" 
                        class="flex-1 bg-[#059669] hover:bg-[#047857] text-white font-medium py-3 px-4 rounded-lg transition-colors">
                    +1 Ep
                </button>
            </div>

            <!-- √ÅREA PARA ADICIONAR INFORMA√á√ïES -->
            <div id="modal-info-adicional" class="bg-[#1f1f1f] p-4 rounded-lg border border-gray-600">
                <div id="info-adicional-container" class="space-y-2">
                    <!-- Conte√∫do adicional ser√° adicionado aqui -->
                    <p class="text-gray-500 text-sm italic">Nenhuma informa√ß√£o adicional adicionada ainda.</p>
                </div>
            </div>

        </div>

    </div>
</div>


<!-- MENU INFERIOR -->
<nav class="menu">
    <button class="menu-btn" onclick="abrirPagina('animes_manager.html')">
        <i data-lucide="home"></i>
        <span>In√≠cio</span>
    </button>
    <button class="menu-btn" onclick="abrirPagina('animes_cadastro.html')">
        <i data-lucide="file-edit"></i>
        <span>Gest√£o</span>
    </button>
    <!-- Lista: Agora vis√≠vel em todos os tamanhos de tela. -->
    <button class="menu-btn  active" onclick="abrirPagina('anime_lista.html')">
        <i data-lucide="list"></i>
        <span>Lista</span>
    </button>

    <!-- Classifica√ß√£o, Estrelas e Torneio est√£o permanentemente ocultos no menu principal,
         e ser√£o acess√≠veis apenas pelo bot√£o 'Mais'. -->
    <button class="menu-btn hidden" onclick="abrirPagina('animes_classificacoes.html')">
        <i data-lucide="bar-chart-2"></i>
        <span>Classifica√ß√£o</span>
    </button>
    <button class="menu-btn hidden" onclick="abrirPagina('animes_estrelas.html')">
        <i data-lucide="star"></i>
        <span>Estrelas</span>
    </button>
    <button class="menu-btn hidden" onclick="abrirPagina('animes_torneio.html')">
        <i data-lucide="trophy"></i>
        <span>Torneio</span>
    </button>

    <!-- Bot√£o de Mais Op√ß√µes (Dropdown) -->
    <!-- Removido 'sm:hidden' para que o bot√£o 'Mais' seja sempre vis√≠vel. -->
    <div class="relative flex">
        <button id="more-options-btn" class="menu-btn" onclick="toggleMoreOptions(event)">
            <i data-lucide="more-horizontal"></i>
            <span>Mais</span>
        </button>

        <!-- Dropdown de Mais Op√ß√µes -->
        <!-- ADICIONADO: 'flex flex-col' para empilhar os itens verticalmente -->
        <div id="more-options-dropdown"
             class="absolute bottom-full mb-2 right-0 w-40 bg-[#1f1f1f] border border-[#2a2a2a]
                    rounded-lg shadow-xl p-2 hidden z-50 flex flex-col">

            <!-- Lista foi removida daqui, pois agora est√° no menu principal. -->
            <!-- Adicionado 'text-left' para garantir o alinhamento do texto √† esquerda dentro do bot√£o. -->
            <button class="dropdown-item text-left" onclick="abrirPagina('animes_classificacoes.html')">
                <i data-lucide="bar-chart-2" class="w-4 h-4"></i> Classifica√ß√£o
            </button>
            <button class="dropdown-item text-left" onclick="abrirPagina('animes_estrelas.html')">
                <i data-lucide="star" class="w-4 h-4"></i> Estrelas
            </button>
            <button class="dropdown-item text-left" onclick="abrirPagina('animes_torneio.html')">
                <i data-lucide="trophy" class="w-4 h-4"></i> Torneio
            </button>
        </div>
    </div>
</nav>

<script>
  lucide.createIcons();
  function abrirPagina(pagina) {
    window.location.href = pagina;
  }
</script>

<!-- FIREBASE -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

    const firebaseConfig = {
        apiKey: "AIzaSyDsbiLPBOda119Qr6Ji69j8TZLpiFixBWI",
        authDomain: "list-games-9bddd.firebaseapp.com",
        projectId: "list-games-9bddd",
        storageBucket: "list-games-9bddd.firebasestorage.app",
        messagingSenderId: "756898313156",
        appId: "1:756898313156:web:9bc660d0a2f4cd07882a91",
        measurementId: "G-GLM50YVLXP"
    };

    const firebaseApp = initializeApp(firebaseConfig);
    const auth = getAuth(firebaseApp);

    const userEmailEl = document.getElementById("user-email");

    let animeCache = [];
    if (!window.animeCache) window.animeCache = [];

    import { getFirestore, collection, getDocs, query, where, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    const db = getFirestore(firebaseApp);

    async function carregarAnimesParaCache() {
        const user = auth.currentUser;
        if (!user) return [];

        const ref = collection(db, "users", user.uid, "animes");
        const snapshot = await getDocs(ref);
        const dados = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        
        // Salva no cache global da janela e no localStorage
        window.animeCache = dados;
        localStorage.setItem(`animes_${user.uid}`, JSON.stringify(dados));
        
        return dados;
    }
    window.carregarAnimesParaCache = carregarAnimesParaCache;

    function toggleMoreOptions(event) {
        event.stopPropagation(); // Previne que o clique feche imediatamente
        const dropdown = document.getElementById('more-options-dropdown');
        dropdown.classList.toggle('hidden');
    }

    // Fun√ß√£o para fechar o dropdown se o usu√°rio clicar fora dele
    document.addEventListener('click', (e) => {
        const dropdown = document.getElementById('more-options-dropdown');
        const button = document.getElementById('more-options-btn');
        if (dropdown && button && !button.contains(e.target) && !dropdown.contains(e.target)) {
            dropdown.classList.add('hidden');
        }
    });

    window.toggleMoreOptions = toggleMoreOptions;

    function toggleFilterDropdown() {
        const dropdownMenu = document.getElementById("dropdownMenu");
        if (!dropdownMenu) {
            console.warn("toggleFilterDropdown: dropdown n√£o encontrado.");
            return;
        }
        dropdownMenu.classList.toggle("hidden");
    }
    window.toggleFilterDropdown = toggleFilterDropdown;

    window.selectFilter = (filterType) => {
        const dropdownMenu = document.getElementById("dropdownMenu");
        const selectedTextEl = document.getElementById("selected-filter-text");

        if (!dropdownMenu || !selectedTextEl) return;

        // Atualiza sele√ß√£o visual
        document.querySelectorAll("#dropdownMenu .filter-option").forEach(option => {
            option.classList.remove("selected");

            if (option.getAttribute("data-filter") === filterType) {
                option.classList.add("selected");

                // Atualiza o texto do bot√£o principal
                const label = option.getAttribute("data-text") || option.textContent.trim();
                selectedTextEl.textContent = label;
            }
        });

        // Fecha o menu
        toggleFilterDropdown();

        // Aplica o filtro
        loadAnimeList(filterType);
    };

    // garante que o dropdown exista antes de anexar listeners
    (function setupDropdownLabelSync() {
    const menu = document.getElementById('dropdownMenu');
    const selectedTextEl = document.getElementById('selected-filter-text');

    if (!menu || !selectedTextEl) {
        // se ainda n√£o existir, tenta novamente depois de 200ms (caso o script rode antes do HTML)
        setTimeout(setupDropdownLabelSync, 200);
        return;
    }

    // Delegation: quando clicar em uma .filter-option, atualiza o texto, a classe selected e fecha o menu.
    menu.addEventListener('click', (ev) => {
        const opt = ev.target.closest('.filter-option');
        if (!opt || !menu.contains(opt)) return;

        // pega o texto do data-text ou o texto interno
        const label = (opt.getAttribute('data-text') || opt.textContent || '').trim();
        if (label) selectedTextEl.textContent = label;

        // atualiza sele√ß√£o visual
        document.querySelectorAll('#dropdownMenu .filter-option').forEach(o => o.classList.remove('selected'));
        opt.classList.add('selected');

        // fecha o dropdown (n√£o chamamos loadAnimeList aqui pois seu onclick inline j√° faz)
        menu.classList.add('hidden');
    });

    // Tamb√©m fecha o dropdown se clicar fora (melhora UX)
    document.addEventListener('click', (ev) => {
        const toggle = document.getElementById('dropdown-toggle');
        if (!menu.contains(ev.target) && ev.target !== toggle && !toggle.contains(ev.target)) {
        menu.classList.add('hidden');
        }
    });

    // opcional: atualiza o texto inicial baseado na op√ß√£o com .selected (se houver)
    const initial = document.querySelector('#dropdownMenu .filter-option.selected');
    if (initial) {
        const label = (initial.getAttribute('data-text') || initial.textContent || '').trim();
        if (label) selectedTextEl.textContent = label;
    }
    })();

    function criarCardAnime(anime) {
        const imagem = anime.IMAGEM || "https://via.placeholder.com/300x450?text=Sem+Imagem";

        return `
            <div class="anime-card" data-nome="${anime.NOME}">

                <div class="card-image">
                    <img src="${imagem}" alt="${anime.NOME}">
                </div>

                <div class="p-2">
                    <h3 class="font-bold text-sm truncate text-white">${anime.NOME}</h3>
                    <p class="text-xs text-gray-400">${anime.ESTILO || "Anime"}</p>
                </div>

            </div>
        `;
    }

    function getTemporadaAtual() {
        const mes = new Date().getMonth() + 1; // 1..12
        if (mes >= 1 && mes <= 3) return 1;    // Inverno
        if (mes >= 4 && mes <= 6) return 4;    // Primavera
        if (mes >= 7 && mes <= 9) return 7;    // Ver√£o
        return 10;                             // Outono
    }

    async function loadAnimeList(filtro = "inacabados") {        
        const user = auth.currentUser;
        if (!user) return;

        // 1. GARANTIA DE DADOS (LocalStorage > Firebase)
        if (!window.animeCache || window.animeCache.length === 0) {
            const cacheKey = `animes_${user.uid}`;
            const cachedData = localStorage.getItem(cacheKey);

            if (cachedData) {
                console.log("üì¶ loadAnimeList: Dados recuperados do localStorage");
                window.animeCache = JSON.parse(cachedData);
            } else {
                console.log("üî• loadAnimeList: Cache vazio, realizando leitura √∫nica no Firebase...");
                await carregarAnimesParaCache(); // Esta fun√ß√£o deve salvar no localStorage
            }
        }

        // Fallback para evitar erro de .filter
        let lista = Array.isArray(window.animeCache) ? [...window.animeCache] : [];

        // 2. APLICA√á√ÉO DOS FILTROS
        if (filtro === "andamento") {
            lista = lista.filter(a => (a.ESTADO || "") === "Andamento");
        } else if (filtro === "inacabados") {
            lista = lista.filter(a => {
                const st = (a.ESTADO || "");
                return st !== "Completo" && st !== "Assistido" && st !== "Desist√™ncia";
            });
        } else if (filtro === "temporada" || filtro === "ult_temporada") {
            // L√≥gica de Temporada (Otimizada para evitar repeti√ß√£o de c√≥digo)
            let anoAlvo = new Date().getFullYear();
            let tempAlvo = getTemporadaAtual();

            if (filtro === "ult_temporada") {
                if (tempAlvo === 1) { tempAlvo = 10; anoAlvo -= 1; }
                else if (tempAlvo === 4) { tempAlvo = 1; }
                else if (tempAlvo === 7) { tempAlvo = 4; }
                else if (tempAlvo === 10) { tempAlvo = 7; }
            }

            lista = lista.filter(anime => {
                const tempStr = (anime.TEMPORADA || "").trim();
                const ano = Number(anime.ANO);
                if (!tempStr || isNaN(ano) || ano !== anoAlvo) return false;
                
                const lower = tempStr.toLowerCase();
                if (lower.includes("outro") || lower.includes("outra")) return false;

                const m = tempStr.match(/\((\d+)\)/);
                if (!m) return false;
                return Number(m[1]) === tempAlvo;
            });
        } else {
            // Filtros gen√©ricos (ex: "Completo", "Pausado")
            lista = lista.filter(a => (a.ESTADO || "").toLowerCase() === String(filtro).toLowerCase());
        }

        // 3. ORDENA√á√ÉO (Opcional: Geralmente por n√∫mero de s√©rie ou nome)
        lista.sort((a, b) => (a.N || 0) - (b.N || 0));

        // 4. RENDERIZA√á√ÉO
        if (typeof renderAnimeCards === "function") {
            renderAnimeCards(lista);
        } else {
            console.error("Fun√ß√£o renderAnimeCards n√£o encontrada!");
        }
    }

    window.loadAnimeList = loadAnimeList;

    // ABRIR MODAL
    function abrirModalAnime(nome) {
        const anime = window.animeCache.find(a =>
            String(a.NOME).replace(/^"+|"+$/g, "") === nome
        );

        if (!anime) {
            console.error("‚ùå Anime n√£o encontrado:", nome);
            return;
        }

        const modal = document.getElementById("anime-modal");
        if (!modal) return;

        document.getElementById("modal-nome").textContent = anime.NOME.replace(/^"+|"+$/g, "");
        document.getElementById("modal-imagem").src =
            anime.IMAGEM || "https://via.placeholder.com/300x450";

        document.getElementById("modal-info").innerHTML = `
            <b>Estado:</b> <span id="modal-estado">${anime.ESTADO || "-"}</span><br>
            <b>Estilo:</b> ${anime.ESTILO || "-"}<br>
            <b>Ano:</b> ${anime.ANO || "-"}<br>
            <b>Temporada:</b> ${anime.TEMPORADA || "-"}<br>
            <b>Epis√≥dios:</b> ${anime.ASSIS || 0} / ${anime.TOTAIS || 0}
        `;

        modal.classList.remove("hidden");
    }

    // FECHAR MODAL
    function fecharModalAnime() {
        document.getElementById("anime-modal").classList.add("hidden");
    }

    // Fun√ß√£o para adicionar informa√ß√£o adicional
    function adicionarInfoAdicional(titulo, conteudo) {
        const container = document.getElementById("info-adicional-container");
        
        // Remover a mensagem padr√£o se ainda existir
        const msgDefault = container.querySelector('.text-gray-500.text-sm.italic');
        if (msgDefault) {
            msgDefault.remove();
        }

        // Criar nova informa√ß√£o
        const infoDiv = document.createElement('div');
        infoDiv.className = 'bg-[#2a2a2a] p-3 rounded border border-gray-600';
        infoDiv.innerHTML = `
            <h4 class="font-medium text-white mb-1">${titulo}</h4>
            <p class="text-sm text-gray-300">${conteudo}</p>
        `;

        container.appendChild(infoDiv);
    }

    // Fun√ß√£o para adicionar epis√≥dio assistido
    function adicionarEpisodioAssistido() {
        const epsAssistidosEl = document.getElementById("modal-eps-assistidos");
        const epsTotaisEl = document.getElementById("modal-eps-totais");
        
        let atual = parseInt(epsAssistidosEl.textContent) || 0;
        const total = parseInt(epsTotaisEl.textContent) || 0;
        
        if (atual < total) {
            atual++;
            epsAssistidosEl.textContent = atual;
            
            // Adicionar ao log de informa√ß√µes
            adicionarInfoAdicional("Epis√≥dio Assistido", `Epis√≥dio ${atual} assistido`);
            
            console.log(`‚úÖ Epis√≥dio ${atual} assistido`);
        } else {
            console.log("‚ö†Ô∏è Todos os epis√≥dios j√° foram assistidos");
        }
    }

    // Fun√ß√£o para alterar estado do anime
    async function alterarEstadoAnime() {
        // 1. Pegar o nome do anime que est√° aberto no modal
        const nomeAnime = document.getElementById("modal-nome").textContent.trim();
        
        // 2. Encontrar o objeto do anime no seu cache
        const anime = window.animeCache.find(item => item.NOME === nomeAnime);

        if (!anime) {
            console.error("Anime n√£o encontrado no cache.");
            return;
        }

        const estadoAtual = anime.ESTADO || "Indefinido";
        const estados = ["Completo", "Andamento", "Incompleto", "Assistido", "Desist√™ncia", "N. Come√ßado", "N. Assistido", "N. Lan√ßado", "N. Sei"];
        
        // Limpar container de informa√ß√µes adicionais
        const container = document.getElementById("info-adicional-container");
        container.innerHTML = '';
        
        // Criar interface de sele√ß√£o de estado
        const estadoInterface = document.createElement('div');
        estadoInterface.className = 'space-y-3';
        estadoInterface.innerHTML = `
            <h4 class="font-medium text-white flex items-center">
                <i data-lucide="settings" class="w-4 h-4 mr-2"></i>
                Alterar Estado
            </h4>
            <div class="space-y-3">
                <div>
                    <label class="block text-sm text-gray-400 mb-1">Novo Estado:</label>
                    <select id="novo-estado-select" 
                            class="w-full bg-[#2a2a2a] border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:border-[#B9314F]">
                        ${estados.map(estado => 
                            `<option value="${estado}" ${estado === estadoAtual ? 'selected' : ''}>${estado}</option>`
                        ).join('')}
                    </select>
                </div>
                <button id="confirmar-novo-estado" 
                        class="w-full bg-[#B9314F] hover:bg-[#992743] text-white font-medium py-2 px-4 rounded-lg transition-colors">
                    Atualizar Estado
                </button>
            </div>
        `;

        container.appendChild(estadoInterface);
        lucide.createIcons();
        
        // L√≥gica do bot√£o Salvar
        const btnConfirmar = document.getElementById("confirmar-novo-estado");
        const selectEstado = document.getElementById("novo-estado-select");
        
        btnConfirmar.addEventListener("click", async () => {
            const novoEstado = selectEstado.value;
            
            // Feedback visual de carregamento
            btnConfirmar.textContent = "Salvando...";
            btnConfirmar.disabled = true;

            try {
                if (!auth.currentUser) throw new Error("Usu√°rio n√£o logado");

                // 1. Buscar a refer√™ncia do documento no Firebase pelo NOME
                const animesRef = collection(db, "users", auth.currentUser.uid, "animes");
                const q = query(animesRef, where("NOME", "==", nomeAnime));
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    throw new Error("Anime n√£o encontrado no banco de dados.");
                }

                // 2. Atualizar no Firebase (pega o primeiro doc encontrado)
                const docRef = querySnapshot.docs[0].ref;
                await updateDoc(docRef, { ESTADO: novoEstado });

                // 3. Atualizar no Cache local (para n√£o precisar recarregar a p√°gina)
                anime.ESTADO = novoEstado;

                // 4. Atualizar o texto no Visual
                const modalEstadoEl = document.getElementById("modal-estado");
                modalEstadoEl.textContent = novoEstado;

                // 5. Mensagem de sucesso
                adicionarInfoAdicional("Sucesso", `Estado alterado para "${novoEstado}"`);
                
                btnConfirmar.textContent = "Atualizar Estado";

            } catch (error) {
                console.error("Erro ao atualizar:", error);
                adicionarInfoAdicional("Erro", "Falha ao atualizar. Tente novamente.");
                btnConfirmar.textContent = "Tentar Novamente";
                btnConfirmar.disabled = false;
            }
        });
        
        console.log("üîÑ Interface de altera√ß√£o de estado criada");
    }

    async function mostrarOpenings() {
        // 1. Encontrar o anime no cache
        const nomeAnime = document.getElementById("modal-nome").textContent.trim();
        const anime = window.animeCache.find(item => item.NOME === nomeAnime);

        if (!anime) {
            console.error("Anime n√£o encontrado no cache.");
            return;
        }

        const container = document.getElementById("info-adicional-container");
        container.innerHTML = '';
        const estilo = anime.ESTILO || "Anime"; // Padr√£o 'Anime' se estiver vazio
        let contentHTML = '';
        let buttonAction = '';

        if (estilo === "Especial" || estilo === "Filme") {
            // Se for ESPECIAL ou FILME
            contentHTML = `
                <div class="bg-[#2a2a2a] p-4 rounded-lg border border-gray-600 text-center">
                    <p class="text-sm text-gray-300">
                        ${estilo} n√£o possuem Openings (Notas).
                    </p>
                </div>
            `;
        } else if (estilo === "Anime") {
            // Se for ANIME (3 pares de nota: M√∫sica e Anima√ß√£o)
            let inputsHTML = '';
            let totalScore = 0;
            let totalPairs = 0;

            for (let i = 1; i <= 3; i++) {
                // Assume keys like OP1_MUSICA, OP1_ANIMACAO exist no objeto anime
                const musicaKey = `OP${i}_MUSICA`;
                const animacaoKey = `OP${i}_ANIMACAO`;
                // Pega o valor atual ou 3 como padr√£o/placeholder
                const scoreMusica = anime[musicaKey] !== undefined ? anime[musicaKey] : '';
                const scoreAnimacao = anime[animacaoKey] !== undefined ? anime[animacaoKey] : '';
                
                // Inclui no c√°lculo apenas se houver notas v√°lidas salvas
                if (anime[musicaKey] !== undefined && anime[animacaoKey] !== undefined) {
                    totalScore += scoreMusica + scoreAnimacao;
                    totalPairs++;
                }

                inputsHTML += `
                    <div class="p-3 bg-neutral-800 rounded-lg border border-gray-700 space-y-2">
                        <h5 class="text-sm font-semibold text-gray-300">Opening ${i}</h5>
                        <div class="flex space-x-3">
                            <div class="flex-1">
                                <label for="op${i}-musica" class="block text-xs text-gray-400 mb-1">M√∫sica (1-5)</label>
                                <input type="number" id="op${i}-musica" value="${scoreMusica}" min="1" max="5" 
                                    class="w-full bg-[#1e1e1e] border border-gray-600 text-white rounded-lg px-2 py-1.5 text-sm focus:outline-none focus:border-[#B9314F]">
                            </div>
                            <div class="flex-1">
                                <label for="op${i}-animacao" class="block text-xs text-gray-400 mb-1">Anima√ß√£o (1-5)</label>
                                <input type="number" id="op${i}-animacao" value="${scoreAnimacao}" min="1" max="5"
                                    class="w-full bg-[#1e1e1e] border border-gray-600 text-white rounded-lg px-2 py-1.5 text-sm focus:outline-none focus:border-[#B9314F]">
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // C√°lculo da nota final: (Total das notas / (Pares v√°lidos * 2))
            const finalScore = totalPairs > 0 ? (totalScore / (totalPairs * 2)).toFixed(2) : "N/A";

            contentHTML = `
                <div class="space-y-4">
                    <div class="flex justify-between items-center p-3 bg-neutral-800 rounded-lg border border-gray-700">
                        <span class="text-sm text-gray-400">Nota M√©dia Total:</span>
                        <span id="openings-nota-total" class="text-lg font-bold text-[#B9314F]">${finalScore}</span>
                    </div>
                    
                    ${inputsHTML}
                    
                    <button id="confirmar-notas-op" 
                            class="w-full bg-[#B9314F] hover:bg-[#992743] text-white font-medium py-2 px-4 rounded-lg transition-colors">
                        Atualizar Notas de Openings
                    </button>
                </div>
            `;
            
            buttonAction = 'full_update';

        } else if (estilo === "Anime Inf.") {
            // Se for ANIME INF. (Atualiza√ß√£o simplificada: 1 select + 2 campos)
            contentHTML = `
                <div class="space-y-4">
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">Qual Opening deseja atualizar?</label>
                        <select id="op-select" 
                                class="w-full bg-[#2a2a2a] border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:border-[#B9314F]">
                            <option value="OP1">Opening 1</option>
                            <option value="OP2">Opening 2</option>
                            <option value="OP3">Opening 3</option>
                        </select>
                    </div>
                    <div class="flex space-x-3">
                        <div class="flex-1">
                            <label for="op-musica-inf" class="block text-xs text-gray-400 mb-1">M√∫sica (1-5)</label>
                            <input type="number" id="op-musica-inf" value="3" min="1" max="5" 
                                class="w-full bg-[#1e1e1e] border border-gray-600 text-white rounded-lg px-2 py-1.5 text-sm focus:outline-none focus:border-[#B9314F]">
                        </div>
                        <div class="flex-1">
                            <label for="op-animacao-inf" class="block text-xs text-gray-400 mb-1">Anima√ß√£o (1-5)</label>
                            <input type="number" id="op-animacao-inf" value="3" min="1" max="5"
                                class="w-full bg-[#1e1e1e] border border-gray-600 text-white rounded-lg px-2 py-1.5 text-sm focus:outline-none focus:border-[#B9314F]">
                        </div>
                    </div>
                    <button id="confirmar-notas-op" 
                            class="w-full bg-[#B9314F] hover:bg-[#992743] text-white font-medium py-2 px-4 rounded-lg transition-colors">
                        Atualizar Opening Selecionada
                    </button>
                </div>
            `;
            buttonAction = 'single_update';
        } else {
             // Fallback para outros estilos
             contentHTML = `
                <div class="bg-[#2a2a2a] p-4 rounded-lg border border-gray-600 text-center">
                    <p class="text-sm text-gray-300">
                        Configura√ß√£o de Openings para o estilo **${estilo}** n√£o definida.
                    </p>
                </div>
            `;
        }
        
        // Estrutura final
        const openingsDiv = document.createElement('div');
        openingsDiv.className = 'space-y-3';
        openingsDiv.innerHTML = `
            <h4 class="font-medium text-white flex items-center">
                <i data-lucide="music" class="w-4 h-4 mr-2"></i>
                Notas de Openings (${estilo})
            </h4>
            ${contentHTML}
        `;

        container.appendChild(openingsDiv);
        lucide.createIcons();
        
        // 2. Adicionar Event Listener para o bot√£o de Atualizar
        const btnConfirmar = document.getElementById("confirmar-notas-op");

        if (btnConfirmar) {
            btnConfirmar.addEventListener("click", async () => {
                btnConfirmar.textContent = "Salvando...";
                btnConfirmar.disabled = true;
                
                try {
                    if (!auth.currentUser) throw new Error("Usu√°rio n√£o logado");

                    // Busca a refer√™ncia do documento no Firebase
                    const animesRef = collection(db, "users", auth.currentUser.uid, "animes");
                    const q = query(animesRef, where("NOME", "==", nomeAnime));
                    const querySnapshot = await getDocs(q);
                    if (querySnapshot.empty) {
                        throw new Error("Anime n√£o encontrado no banco de dados.");
                    }
                    const docRef = querySnapshot.docs[0].ref;
                    let updateData = {};

                    if (buttonAction === 'full_update') {
                        // L√≥gica de atualiza√ß√£o completa para 3 pares
                        let newTotalScore = 0;
                        let newTotalPairs = 0;
                        
                        for (let i = 1; i <= 3; i++) {
                            const musicaInput = document.getElementById(`op${i}-musica`);
                            const animacaoInput = document.getElementById(`op${i}-animacao`);
                            
                            const musica = parseInt(musicaInput.value);
                            const animacao = parseInt(animacaoInput.value);
                            
                            // Valida√ß√£o e adi√ß√£o ao objeto de update
                            if (musica >= 1 && musica <= 5) {
                                updateData[`OP${i}_MUSICA`] = musica;
                                // Atualiza o cache local
                                anime[`OP${i}_MUSICA`] = musica; 
                            }
                            if (animacao >= 1 && animacao <= 5) {
                                updateData[`OP${i}_ANIMACAO`] = animacao;
                                // Atualiza o cache local
                                anime[`OP${i}_ANIMACAO`] = animacao;
                            }
                        }
                        
                        // Recalcula e exibe a nota total ap√≥s a atualiza√ß√£o do cache
                        for (let i = 1; i <= 3; i++) {
                            const musica = anime[`OP${i}_MUSICA`];
                            const animacao = anime[`OP${i}_ANIMACAO`];
                            if (musica !== undefined && animacao !== undefined) {
                                newTotalScore += musica + animacao;
                                newTotalPairs++;
                            }
                        }
                        const finalScore = newTotalPairs > 0 ? (newTotalScore / (newTotalPairs * 2)).toFixed(2) : "N/A";
                        document.getElementById("openings-nota-total").textContent = finalScore;


                    } else if (buttonAction === 'single_update') {
                        // L√≥gica de atualiza√ß√£o simples para 1 par
                        const opSelect = document.getElementById('op-select').value;
                        const musicaInput = document.getElementById('op-musica-inf');
                        const animacaoInput = document.getElementById('op-animacao-inf');
                        
                        const musica = parseInt(musicaInput.value);
                        const animacao = parseInt(animacaoInput.value);
                        
                        if (musica >= 1 && musica <= 5) {
                            updateData[`${opSelect}_MUSICA`] = musica;
                            anime[`${opSelect}_MUSICA`] = musica; // Atualiza o cache
                        }
                        if (animacao >= 1 && animacao <= 5) {
                            updateData[`${opSelect}_ANIMACAO`] = animacao;
                            anime[`${opSelect}_ANIMACAO`] = animacao; // Atualiza o cache
                        }
                    }
                    
                    // 3. Salva no Firebase
                    if (Object.keys(updateData).length > 0) {
                        await updateDoc(docRef, updateData);
                        adicionarInfoAdicional("Sucesso", `Notas de Openings atualizadas!`);
                    } else {
                        adicionarInfoAdicional("Aviso", "Nenhuma nota v√°lida para salvar.");
                    }

                    btnConfirmar.textContent = "Atualizado!";
                    setTimeout(() => {
                        btnConfirmar.textContent = (buttonAction === 'full_update' ? "Atualizar Notas de Openings" : "Atualizar Opening Selecionada");
                        btnConfirmar.disabled = false;
                    }, 1500);
                    
                } catch (error) {
                    console.error("Erro ao atualizar notas de Openings:", error);
                    adicionarInfoAdicional("Erro", "Falha ao atualizar. Tente novamente.");
                    btnConfirmar.textContent = "Tentar Novamente";
                    btnConfirmar.disabled = false;
                }
            });
        }

        console.log(`üéµ Openings mostradas para estilo: ${estilo}`);
    }

    // Tornar fun√ß√µes globais
    window.abrirModalAnime = abrirModalAnime;
    window.fecharModalAnime = fecharModalAnime;
    window.adicionarInfoAdicional = adicionarInfoAdicional;
    window.adicionarEpisodioAssistido = adicionarEpisodioAssistido;
    window.alterarEstadoAnime = alterarEstadoAnime;
    window.mostrarOpenings = mostrarOpenings;

    // Configurar eventos do modal quando DOM estiver pronto
    function setupModalEvents() {
        const modal = document.getElementById("anime-modal");

        const closeBtn = document.getElementById("anime-close-btn");

        if (closeBtn) {
            closeBtn.addEventListener("click", fecharModalAnime);
        } else {
            console.error("‚ùå Bot√£o de fechar n√£o encontrado");
        }

        if (modal) {
            modal.addEventListener("click", (e) => {
                if (e.target === modal) {
                    fecharModalAnime();
                }
            });
        } else {
            console.error("‚ùå Modal n√£o encontrado");
        }

        // Configurar eventos dos bot√µes de a√ß√£o
        const btnOpenings = document.getElementById("btn-openings");
        const btnEstado = document.getElementById("btn-estado");
        const btnEpisodio = document.getElementById("btn-episodio");

        if (btnOpenings) {
            btnOpenings.addEventListener("click", () => {
                console.log("üéµ Bot√£o Openings clicado");
                mostrarOpenings();
            });
        }

        if (btnEstado) {
            btnEstado.addEventListener("click", () => {
                console.log("üìä Bot√£o Estado clicado");
                alterarEstadoAnime();
            });
        }

        if (btnEpisodio) {
            btnEpisodio.addEventListener("click", () => {
                console.log("‚ûï Bot√£o +1 Ep clicado");
                adicionarEpisodioAssistido();
            });
        }
    }

    // Chamar quando DOM estiver pronto
    if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", setupModalEvents);
    } else {
        setupModalEvents();
    }

    function renderAnimeCards(lista) {        
        const grid = document.getElementById("anime-list-grid");
        if (!grid) {
            console.error("renderAnimeCards: #anime-list-grid n√£o encontrado.");
            return;
        }

        grid.innerHTML = "";

        if (!Array.isArray(lista) || lista.length === 0) {
            grid.innerHTML = `
                <div class="col-span-full text-center text-gray-400">
                    Nenhum anime encontrado.
                </div>`;
            return;
        }
        
        lista.forEach(anime => {            
            const nome = anime.NOME || "Sem nome";
            const imagem = anime.IMAGEM || "";
            const estilo = anime.ESTILO || "";
            const estado = anime.ESTADO || "";

            // ‚û§ NOVOS CAMPOS
            const ano = anime.ANO || "";
            const temporada = anime.TEMPORADA || "";
            const epAssistidos = anime.ASSIS || 0;
            const epTotais = anime.TOTAIS || 0;

            // Exibi√ß√£o de temporada
            let temporadaLabel = temporada;
            if (temporada === "1") temporadaLabel = "Inverno";
            else if (temporada === "4") temporadaLabel = "Primavera";
            else if (temporada === "7") temporadaLabel = "Ver√£o";
            else if (temporada === "10") temporadaLabel = "Outono";
            else if (temporada === "Outra") temporadaLabel = "Outra";

            const div = document.createElement("div");
            div.className =
                "anime-card cursor-pointer bg-[#151515] rounded-lg overflow-hidden shadow-md border border-[#2a2a2a]";
            div.setAttribute("data-nome", nome);

            div.innerHTML = `
                <div class="w-full h-40 overflow-hidden bg-[#111] flex items-center justify-center">
                    <img 
                        src="${imagem}"
                        class="w-full h-full object-cover rounded-lg"
                        onerror="
                            this.onerror=null;
                            this.src='';
                            this.removeAttribute('src');
                            this.closest('.img-box')?.classList.add('no-img');
                        "
                    />
                </div>

                <div class="p-3">

                    <!-- Nome -->
                    <h3 class="font-bold text-sm text-white truncate">${nome}</h3>

                    <!-- Ano + Temporada -->
                    <p class="text-xs text-gray-400">
                        ${estilo} ‚Ä¢ ${ano} ${temporadaLabel ? "‚Ä¢ " + temporadaLabel : ""}
                    </p>

                    <!-- Epis√≥dios -->
                    <p class="text-xs text-gray-400 mt-1">
                        Epis√≥dios: <span class="text-white">${epAssistidos}</span> / ${epTotais}
                    </p>

                    <!-- Estado -->
                    <p class="text-xs text-gray-500 mt-1">Estado: ${estado}</p>
                </div>
            `;

            div.addEventListener("click", (e) => {
                e.preventDefault();
                e.stopPropagation();
                const nomeAnime = div.getAttribute("data-nome");

                if (typeof window.abrirModalAnime === "function") {
                    window.abrirModalAnime(nomeAnime);
                } else {
                    console.error("‚ùå abrirModalAnime N√ÉO encontrada no window");
                    console.log("‚ùå window.abrirModalAnime:", window.abrirModalAnime);
                }
            });

            grid.appendChild(div);
        });
    }
    window.renderAnimeCards = renderAnimeCards;

    window.fecharModal = () => {
        document.getElementById("anime-modal").classList.add("hidden");
    };
    
    onAuthStateChanged(auth, async (user) => {        
        if (!user) {
            console.log("üîÑ Redirecionando para login...");
            window.location.href = "login.html";
            return;
        }

        document.getElementById("loading-indicator").classList.remove("hidden");
        document.getElementById("error-message").classList.add("hidden");

        try {
            // üì¶ Tenta pegar do Cache primeiro
            const cacheKey = `animes_${user.uid}`;
            const cachedData = localStorage.getItem(cacheKey);
            
            if (cachedData) {
                console.log("üì¶ Lista: Carregando dados do Cache Local");
                window.animeCache = JSON.parse(cachedData);
            } else {
                // üî• Se n√£o tiver cache, busca uma √∫nica vez no Firebase
                console.log("üî• Lista: Cache vazio, buscando no Firebase...");
                await carregarAnimesParaCache(); 
            }
                        
            if (!window.animeCache || window.animeCache.length === 0) {
                console.log("‚ö†Ô∏è Nenhum anime encontrado");
                document.getElementById("error-message").classList.remove("hidden");
            } else {
                // Renderiza a lista usando os dados que agora est√£o em window.animeCache
                await loadAnimeList("inacabados");
            }
            
        } catch (error) {
            console.error("‚ùå Erro ao carregar dados:", error);
            document.getElementById("error-message").classList.remove("hidden");
        } finally {
            document.getElementById("loading-indicator").classList.add("hidden");
        }

        if (user?.email) userEmailEl.textContent = user.email;
    });

    // Verifica√ß√£o final das fun√ß√µes
    document.addEventListener("DOMContentLoaded", () => {
        window.debugCache = () => {
            console.log("üîç Estado atual do animeCache:", window.animeCache);
            console.log("üîç Quantidade de animes:", window.animeCache?.length || 0);
            if (window.animeCache && window.animeCache.length > 0) {
                console.log("üîç Primeiros 3 animes:", window.animeCache.slice(0, 3));
            }
        };

        // Fun√ß√£o de teste manual
        window.testarModal = async () => {
            console.log("üß™ Verificando cache para teste...");
            window.debugCache();
            
            if (window.animeCache && window.animeCache.length > 0) {
                const primeiroAnime = window.animeCache[0];
                console.log("üß™ Testando modal com:", primeiroAnime.NOME);
                window.abrirModalAnime(primeiroAnime.NOME);
            } else {
                console.log("üß™ Nenhum anime no cache para testar");
                console.log("üß™ Tentando recarregar...");
                try {
                    await carregarAnimesParaCache();
                    console.log("üß™ Recarregamento conclu√≠do");
                    window.debugCache();
                    
                    if (window.animeCache && window.animeCache.length > 0) {
                        window.testarModal(); // Recursivo para tentar novamente
                    } else {
                        console.log("üß™ Ainda sem dados ap√≥s recarregamento");
                    }
                } catch (error) {
                    console.error("üß™ Erro ao recarregar:", error);
                }
            }
        };
    });
</script>

</body>
</html>
